En este apartado se explicará el funcionamiento de la aplicación, que permitirá poder obtener datos en tiempo real de cuanto una persona en promedio espera hasta ser atendido en la caja.

\section{Proceso de iniciar la aplicación}

Para que la aplicación funcione se tiene que correr mediante terminar, utilizando el siguiente comando que aparece en la Figura \ref{fig:labeling15}, el comando  correrá el código escrito y se agregan ciertos parámetros que necesita Darknet, el cual definirán el funcionamiento.

\begin{figure}[h]
	\centering
	\includegraphics[width=150mm, height=45mm]{imagenes/persona26.png}
	\caption{Comando para que funcione la aplicación con los parámetros necesarios.}
	\source{Elaboración propia}
	\label{fig:labeling15}
\end{figure}

Estos parámetros definen con qué tipo de video se trabajará, si será un video local, usar una cámara convencional o usar una cámara IP. Otro parámetro importante es definir si los resultados del análisis se guardara en un video.	

\section{Configuración de parámetros}

En este apartado se definen los valores de los parámetros necesarios para que la aplicación funcione. Como ser el caso del tiempo de espera máximo de una persona, ya que es un valor que se utiliza bastante en las funciones. Esto parametros se observarán en el Codigo \ref{60}.

\begin{lstlisting}[language=Python,caption={Se definen los parámetros de tiempo máximo de espera, el límite de detección y el máximo tiempo promedio de espera.},captionpos=b,label=60]
DETECTION_EVENTS = []
MAXIMUM_AVERAGE_WAITING_TIME_IN_SECONDS = 2
MAXIMUM_NUMBER_OF_PEOPLE_DETECTED = 0
MAXIMUM_TIME_WAITING_IN_SECONDS = 10
LIMIT_LINE_OF_DETECTION = 400
\end{lstlisting}

Cambiando estos datos, el proyecto se puede adaptar a diferentes requerimientos que tiene un supermercado al momento de determinar el tiempo máximo de espera de una persona. Ya que no todos los supermercados tienen el mismo flujo de clientes y eso ocasione que un tiempo máximo de espera para un lugar sea diferente a otro.

Otro de los parámetros importantes es definir la posición del límite de detección, ya que esto variara dependiendo de dónde se encuentre la cámara de seguridad y la resolución en la que graba. Definiendo bien este parámetro el proyecto se adecuará de mejor manera a diferentes supermercados que decidan utilizar esta aplicación.  


\section{Proceso de detección y cálculo de tiempo de espera promedio}

Cuando la aplicación ya está iniciada comenzara a realizar la detección en cada Frame del video esperando detectar alguna persona. 
Ahora, cuando llega a detectar una persona guardara los siguientes datos: la hora en la que fue detectada, el número de detección, la posición del objeto detectado.

Paralela a la acción anterior, también comienza a ejecutarse continuamente 2 funciones que calcularán el tiempo promedio de espera de un cliente.
Una función ira calculando el tiempo promedio de espera dependiendo de la cantidad de personas que están haciendo fila, esto se realiza gracias a los datos que se almacenan en una lista, esta lista se observa en la Figura \ref{fig:labeling16}. Esta función que se puede ver en el siguiente Código \ref{25}, realiza un procedimiento de crear una lista en el que se suman la diferencia del tiempo en el que fueron detectados los objetos.
\begin{lstlisting}[language=Python,caption={Función que suma la diferencia de tiempo entre cada detección en segundos.},captionpos=b,label=25]
def calculate_average_waiting_time_in_seconds():
    datetime_diff_in_seconds = []
    for oldest_event, newest_event in zip(DETECTION_EVENTS,
    	 DETECTION_EVENTS[1:]):
        diff = oldest_event['datetime_event'] - 
        	newest_event['datetime_event']
        datetime_diff_in_seconds.append(abs(diff.total_seconds()))
    return sum(datetime_diff_in_seconds)
\end{lstlisting}

Teniendo este dato, se procede a calcular el tiempo promedio de espera, para ello se ejecutará diversos cálculos para poder obtenerlo, esto se aprecia en el siguiente Código \ref{26}.
\begin{lstlisting}[language=Python,caption={Cálculo para la obtención del tiempo promedio de espera.},captionpos=b,label=26]
        if DETECTION_EVENTS:
            waiting_time_in_seconds = 
            	calculate_average_waiting_time_in_seconds()
            last_number_of_people_detected =
            	 get_last_number_of_people_detected()
            average_waiting_time_in_seconds = 
            	waiting_time_in_seconds / 
            			last_number_of_people_detected
            print("AVG: {}".format(average_waiting_time_in_seconds))
            diff2 = DETECTION_EVENTS[0]["datetime_event"] - 
            		datetime.now()
            max_time = abs(diff2.total_seconds())
\end{lstlisting}

La segunda función que se encarga de activar la alarma consiste en saber cuándo un objeto llega a cruzar el límite dibujado anteriormente. Ahora, si un objeto detectado no llego a cruzar este límite en un tiempo determinado, se llega a considerar que hay un problema en la fila y activara la alarma, la otra función importante se ve en el Código \ref{27}

\begin{lstlisting}[language=Python,caption={Funcción para calcular el objeto más cercano al límite.},captionpos=b,label=27]
def create_list_of_closest_person_detected():
    list_closest_person_detected = [0, 0]
    for closest_detecttion in DETECTION_EVENTS:
        person_closes = closest_detecttion[0]
        		['detection_position', 0]
        list_closest_person_detected.append(person_closes)
        max_value = np.max(list_closest_person_detected)
    return max_value
\end{lstlisting}

Con el anterior código se llega a saber cuál es la persona que este al frente de la fila y con ellos determinar si se tarda mucho en ser atendido, ya que eso se sabe cuando cruza el límite establecido.

\clearpage
Los cálculos de estas funciones se reiniciaran cada vez que salte la alarma o cuando sea atendida una persona.
La alarma suena cada vez que se supere el tiempo máximo de espera, el cual se define al comienzo de la aplicación. 

Al sonar la alarma se inician 2 procesos importantes, el primero se encargará de generar un \say{popup} con un mensaje avisando que es recomendable abrir una nueva caja. Por otra parte, la otra función se encarga de registrar de la hora en la que se activó la alarma, para así tener un registro para observar cuales son los periodos del día con más problemas en atender al cliente. Con esa información se puede buscar una solución permanente que mejore la experiencia del cliente al tener menos tiempo de espera.

Este registro de las alarmas se realiza con MongoDB, el cual lo guardara en este caso de manera local, y la forma en la guarda los datos se observa en la Tabla \ref{tab:fruta2}.

\begin{table}[h]
\begin{center}
\caption{Datos guardados en la base de datos mediante MongoDB.}
\begin{tabular}{| r | l |}
\hline \textbf{Identificador} & \textbf{Fecha} \\ \hline
5f6f64d68f91d1f84b702b01 & 2020-09-26T11:57:10.293Z  \\
5f6f651f8f91d1f84b702b02 & 2020-09-26T11:58:23.472Z \\ 
5f6f65358f91d1f84b702b03 & 2020-09-26T11:58:45.617Z \\ 
5f6f65658f91d1f84b702b04 & 2020-09-26T11:59:33.228Z \\ \hline
\end{tabular}
%\caption{Datos guardados en la base de datos mediante MongoDB.}
\label{tab:fruta2}
\source{Elaboración propia.}
\end{center}
\end{table}

\section{Prueba de la aplicación}

En este apartado se desarrollará un caso de estudio ficticio, donde se hará uso de la aplicación para poder saber cuántas veces suena la alarma en un día de atención normal con una sola caja.

Antes de poder ejecutar debidamente la aplicación se tiene que configurar los parámetros principales, el cual dependerá de los requerimientos del supermercado. En este caso, este supermercado considera que el tiempo promedio máximo es de 5 segundos y el tiempo máximo de una persona sin cruzar el límite es de 10 segundos.  Otro factor importante es la posición de la cámara, que en este caso se encuentra enfocando la parte lateral de la fila, lo cual llega a modificar la posición del límite de detección. Estas modificaciones se observa en el Código \ref{70}.

\begin{lstlisting}[language=Python,caption={Configuración de los parámetros para el caso de estudio.},captionpos=b,label=70]
DETECTION_EVENTS = []
MAXIMUM_AVERAGE_WAITING_TIME_IN_SECONDS = 5
MAXIMUM_NUMBER_OF_PEOPLE_DETECTED = 0
MAXIMUM_TIME_WAITING_IN_SECONDS = 10
LIMIT_LINE_OF_DETECTION = 550
\end{lstlisting}

\clearpage
Una vez establecido los parámetros, se procede a ejecutar la aplicación de la manera en la que se indicó en la Figura \ref{fig:labeling15}. En el periodo en que la aplicación estaba en funcionamiento se llegó a detectar 4 alarmas, las cuales fueron registradas en la base de datos y eso nos permite saber en qué momento salto la alarma y como este procedimiento de detección igual se guarda en un video se puede ver por cual de los problemas se registró la alarma.


La primera alarma se activa debido a que se superó el tiempo promedio máximo de espera sin cruzar el límite, este caso se observa en la Figura \ref{fig:labeling80}, donde la fila solo era de una persona y aun así hubo demora para llegar a ser atendido.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{imagenes/caso1.png}
	\caption{Primer caso en el que se activa la alarma debido a la falta de movimiento en la fila.}
	\source{Elaboración propia}
	\label{fig:labeling80}
\end{figure}

El siguiente caso se activa debido a que se supera el tiempo promedio máximo de espera, lo cual se observa en la Figura \ref{fig:labeling81}, en este caso hay una situación especial donde se demuestra la buena detección que realiza la red neuronal entrenada, ya que una de las personas está con un perro y a pesar de eso la red neuronal es capaz de detectarlo e ignorar al perro.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{imagenes/caso2.png}
	\caption{Segundo caso en el que se activa la alarma debido a que se superó el tiempo máximo de espera.}
	\source{Elaboración propia}
	\label{fig:labeling81}
\end{figure}

\clearpage
El tercer y cuarto caso en el que se activa la alarma es por la falta de movimiento en la fila, en la Figura \ref{fig:labeling82} se observa el momento exacto donde se registra la alarma. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{imagenes/caso4.png}
	\caption{Cuarto caso en el que se activa la alarma debido nuevamente a la falta de movimiento en la fila.}
	\source{Elaboración propia}
	\label{fig:labeling82}
\end{figure}

Todos los casos en el que se activó la alarma fueron registrados en la base de datos que genera MongoDB, estos datos guardados se observara mejor en la Tabla \ref{tab:fruta3}. Con esta información se puede determinar que si hay un problema en la atención de las cajas, debido a que se activó varias veces la alarma y el caso más frecuente es la falta de movimiento en la fila, con esto se podría determinar que el problema podría venir por parte del cajero, debido a que realiza una atención lenta.

\begin{table}[h]
\begin{center}
\caption{Datos guardados en la base de datos.}
\begin{tabular}{| r | l |}
\hline \textbf{Identificador} & \textbf{Fecha} \\ \hline
5fb47795f1986a8bdb48115a & 2020-11-17T09:23:33.793Z  \\
5fb47838f1986a8bdb48115b & 2020-11-17T09:26:16.45Z \\ 
5fb47958f1986a8bdb48115c & 2020-11-17T09:45:01.503Z \\ 
5fb48147f1986a8bdb48115d & 2020-11-17T09:48:50.109Z\\ \hline
\end{tabular}
%\caption{Datos guardados en la base de datos.}
\label{tab:fruta3}
\source{Elaboración propia.}
\end{center}
\end{table}








